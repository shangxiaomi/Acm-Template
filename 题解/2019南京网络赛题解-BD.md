
##[B.super_log](https://nanti.jisuanke.com/t/41299)
###题意：
求$$a^{a^{a^{a^{...}}}}$$
b表示有几个a,b=0时答案为1。
特殊情况：
1.$m=1$时答案为0
2.$m\ne1$&&$a=1$时答案为1
3.$m\ne1$&&$b=1$时答案为1
然后就欧拉降幂迭代就行。注意在这里欧拉函数不打表反而比较快
注意：**搞清楚各个函数的模到底是MOD还是phi（MOD）**
附上降幂公式：
$$a^b=
\begin{cases}
{a^{b\%phi[p]}}& {gcd(a,p)=1}\\
{a^b}& gcd(a,p)\ne 1\;\&\&\;b<phi[p]\;\&\&\;b\;\%\;phi\ne 0\\
{a^{b\%phi[p]+phi[p]}} & gcd(a,p)\ne1\;\&\&\;b\ge phi[p]\;||\;b\;\%\;phi=0
 \end{cases}$$
注意迭代过程中会出现的W=lowPow( A, B - 1, phi)=0的情况

伪代码
if(模 == 1) ans = 0，return
if(底数 == 1) ans = 1, return 
if(gcd == 1) ans = ... return
W = 指数。
if(W < phi[模]&&W!=0) ans = a ^ W return
else ans = a ^ (W + phi[模]) return



```cpp
#include<bits/stdc++.h>
#define rr(o) (o << 1 | 1)
#define MID(l,r)  (l+r)>>1
using namespace std;
typedef long long LL;
typedef long long ll;
typedef double db;
const int MAXN=1000000+7;
long long eular(long long n)
{
    long long ans = n;
    for(int i = 2; i*i <= n; i++)
    {
        if(n % i == 0)
        {
            ans -= ans/i; //等价于通项，把n乘进去
            while(n % i == 0) //确保下一个i是n的素因数
                n /= i;
        }
    }
    if(n > 1)ans -= ans/n; //最后可能还剩下一个素因数没有除
    return ans;
}
int quickPow(int a,int b, int MOD){
    int ans = 1;
    while(b){
        if(b % 2 == 1)
            ans = 1LL * ans * a % MOD;
        a = 1LL * a * a % MOD;
        b = b / 2;
    }
    return ans;
}

LL lowPow(LL A , LL B , LL MOD){
    if( MOD == 1 ) return 0;
    if( B == 0 ) return 1;
    int G=__gcd(A,MOD);
    int phi=eular(MOD);
    LL W=lowPow( A, B - 1, phi);
    if(G==1)return quickPow(A,W%phi,MOD);
    if( W < phi&&W) return quickPow(A , W , MOD);
    return quickPow(A, W + phi , MOD);
}

int main()
{
    int T;
    scanf("%d",&T);
    while(T--){
        int a,b,m;
        scanf("%d %d %d",&a,&b,&m);
        if(a==1){
            if(m!=1)cout<<1<<endl;
            else cout<<0<<endl;
            continue;
        }
        cout<<lowPow(a, b, m)<<endl;
    }
    return 0;
}

```



##[D.萝卜丝](https://nanti.jisuanke.com/t/41301)
###题意：
图上走。每一天都有出度+1的概率走到下一任意节点或者停留一天。第i天的花费为i。
有两个期望，天数期望和花费期望。
$$day[i]=\sum{\frac{1}{1+out[i]}(day[j]+1)}+\frac{1}{1+out[i]}(day[i]+1)$$
$$dp[i]=\sum{\frac{1}{out[i]+1}(dp[j]+day[i])+\frac{1}{out[i]+1}(dp[i]+day[i])}$$
然后就单纯的从后向前推就行。
```cpp
#include<bits/stdc++.h>

using namespace std;
typedef long long LL;
typedef long long ll;
typedef double db;
const int MAXN=400000+7;
vector<int> nextto[MAXN];
int inde[MAXN], order[MAXN], outde[MAXN];
double dp[MAXN], day[MAXN];
void addedge(int st, int ed){
    nextto[st].push_back(ed);
    inde[ed] ++;
    outde[st] ++;
}
int N, M;
void init(){
    memset(inde, 0, sizeof inde);
    memset(outde, 0, sizeof outde);
    for(int i = 0; i <= N; i ++)
        nextto[i].clear();
}
void topo(){
    queue<int> q;
    int cnt=0;
    /*
    for(int i = 0; i < N; i ++){
        if(inde[i] == 0)    q.push(i), order[cnt ++] = i;
    }*/
    order[cnt++]=1;
    q.push(1);

    while(!q.empty()){
        int now = q.front();
        q.pop();
        for(auto ed : nextto[now]){
            inde[ed] --;
            if(inde[ed] == 0)   order[cnt ++] = ed, q.push(ed);
        }

    }
}
int main()
{
    int T;
    scanf("%d",&T);
    while(T--){
        init();
        scanf("%d %d",&N,&M);
        for(int i=0;i<M;i++){
            int a,b;
            scanf("%d%d" , &a, &b);
            addedge(a, b);
        }
        topo();
        for(int i = N-1; i >= 0; i --){
            int U = order[i];
            day[U] = 0.0;
            if(outde[U] == 0)continue;
            for(auto ed : nextto[U])
                day[U] += day[ed];
            day[U] /= 1.0 * outde[U];
            day[U] += 1.0 / outde[U] + 1;
        }
        for(int i = N-1; i >= 0; i --){
            int U = order[i];
            dp[U] = 0.0;
            if(outde[U] == 0) continue;
            for(auto ed : nextto[U])
                dp[U] += dp[ed];
            dp[U] /= 1.0 * outde[U];
            dp[U] += day[U] * ( 1 + 1.0 * outde[U]) / outde[U];
        }
        printf("%.2f\n", dp[1]);
    }
    return 0;
}

```
